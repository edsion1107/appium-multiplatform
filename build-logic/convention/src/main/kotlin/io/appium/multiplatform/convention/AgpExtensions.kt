package io.appium.multiplatform.convention

import com.android.build.api.artifact.SingleArtifact
import com.android.build.api.variant.ApplicationVariant
import com.android.build.api.variant.impl.VariantOutputImpl
import org.gradle.api.file.RegularFile
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Provider

/**
 * Resolves the APK file paths for a given [ApplicationVariant] and adds them to the [apks] list.
 *
 * This method populates the [apks] [ListProperty] with [RegularFile] instances representing
 * the expected paths of the APK files generated by the build.
 *
 * **Important Note:** This method only resolves the *expected* paths of the APK files and
 * does not guarantee their actual existence on disk. Consumers of the [apks] list should
 * perform their own checks for file existence (e.g., using `File.exists()` and `File.isFile()`)
 * before attempting to access or use the files. The actual APK files might be missing due to
 * build failures, clean operations, or other reasons.
 *
 * Example usage within a Gradle plugin's `apply` method, assuming `MyTask` is a custom task:
 * ```kotlin
 *
 * // Define your custom task, e.g., in the same file or a separate one.
 * abstract class MyTask : DefaultTask() {
 *     @get:InputFiles
 *     abstract val apkFiles: ListProperty<RegularFile>
 *
 *     @TaskAction
 *     fun run() {
 *         apkFiles.get().forEach { apkFile ->
 *             if (apkFile.asFile.exists() && apkFile.asFile.isFile) {
 *                 println("Found APK: ${apkFile.asFile.absolutePath}")
 *                 // Process the APK file, e.g., upload, analyze, etc.
 *             } else {
 *                 println("APK not found or is not a file: ${apkFile.asFile.absolutePath}")
 *             }
 *         }
 *     }
 * }
 *
 * class MyPlugin : Plugin<Project> {
 *     override fun apply(project: Project) {
 *         project.extensions.configure<ApplicationAndroidComponentsExtension> {
 *             onVariants { variant ->
 *                 val apks = project.objects.listProperty<RegularFile>()
 *                 variant.resolveApks(apks)
 *                 project.tasks.register<MyTask>("myTaskFor${variant.name.replaceFirstChar { it.uppercase() }}") {
 *                     this.apkFiles.set(apks)
 *                 }
 *             }
 *         }
 *     }
 * }
 * ```
 *
 * @param apks A [ListProperty] to which the resolved [RegularFile] paths of the APKs will be added.
 *
 * @since Android Gradle Plugin 7.0
 */
fun ApplicationVariant.resolveApks(apks: ListProperty<RegularFile>) {
    val apkDirProvider = artifacts.get(SingleArtifact.APK)
    outputs.filterIsInstance<VariantOutputImpl>().forEach { output ->
        apks.add(apkDirProvider.flatMap { apkDir ->
            apkDir.file(output.outputFileName)
        })
    }
}

/**
 * Resolves the primary APK file path for a given [ApplicationVariant].
 *
 * This function returns a [Provider] of a [RegularFile] that points to the main APK file
 * generated by the build for this variant. It assumes there is at least one output.
 * If no output is found, it will throw an error.
 *
 * **Important Note:** This method only provides a [Provider] to the *expected* path of the APK file
 * and does not guarantee its actual existence on disk. Consumers should perform their own checks
 * for file existence before attempting to access it.
 *
 * Example usage within a Gradle task:
 * ```kotlin
 * abstract class ProcessApkTask : DefaultTask() {
 *     @get:InputFile
 *     abstract val apkFile: RegularFileProperty
 *
 *     @TaskAction
 *     fun run() {
 *         val file = apkFile.get().asFile
 *         if (file.exists()) {
 *             println("Processing APK: ${file.absolutePath}")
 *         } else {
 *             println("APK not found: ${file.absolutePath}")
 *         }
 *     }
 * }
 *
 * // In your plugin's onVariants block:
 * onVariants { variant ->
 *     project.tasks.register<ProcessApkTask>("process${variant.name.capitalize()}Apk") {
 *         apkFile.set(variant.resolveApk())
 *     }
 * }
 * ```
 *
 * @return A [Provider<RegularFile>] pointing to the resolved main APK file.
 * @throws IllegalStateException if no [VariantOutputImpl] is found for the variant.
 */
fun ApplicationVariant.resolveApk(): Provider<RegularFile> {
    val dirProvider = artifacts.get(SingleArtifact.APK)
    val outputImpl = outputs.filterIsInstance<VariantOutputImpl>().firstOrNull()
        ?: error("No VariantOutputImpl found for variant $name")
    val filename = outputImpl.outputFileName
    return dirProvider.flatMap { it.file(filename) }
}

/**
 * Updates the output filename for each APK variant using a custom naming strategy.
 *
 * This method iterates through all [VariantOutputImpl] instances for the [ApplicationVariant]
 * and applies a custom naming logic based on the provided flags.
 *
 * Example usage:
 * ```kotlin
 * // In your plugin's onVariants block:
 * onVariants { variant ->
 *     variant.updateFilename(withVersionName = true, withVersionCode = true)
 * }
 * ```
 * The above would change `app-debug.apk` to something like `app-debug-v1.0.0-100.apk`.
 *
 * @param withVersionName If `true`, appends the version name to the filename.
 * @param withVersionCode If `true`, appends the version code to the filename.
 */
fun ApplicationVariant.updateFilename(
    withVersionName: Boolean = false,
    withVersionCode: Boolean = false,
) {
    outputs.filterIsInstance<VariantOutputImpl>().forEach { output ->
        val originalName = output.outputFileName.get()
        val suffix = buildString {
            if (withVersionName) {
                // In this onVariants block, it's safe to .get() the value.
                append("-v${output.versionName.get()}")
            }
            if (withVersionCode) {
                append("-${output.versionCode.get()}")
            }
        }

        if (suffix.isNotEmpty()) {
            val newName = originalName.replace(Regex("\\.apk$"), "$suffix.apk")
            output.outputFileName.set(newName)
        }
    }
}
